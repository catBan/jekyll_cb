---
layout: post
title:  "python学习-捡芝麻"
date:   2016-10-31 15:08:31 +0800
update: 2016-11-14 +0800
categories: 学无止境
tag: Python
---

* content
{:toc}



``

### #1.python文件在linux下可直接运行 , 方法是在.py文件首行加上代码:

```

#!/usr/bin/env python3

```

并赋予文件执行权限:

```

$ chmod a+x  xx.py

```

就可以在终端中直接运行了：

```

$  ./xx.py

```

### #2.关于特殊字符转义

使用"\"来转义特殊字符如需要输出 "\t"时，写成"\\t".

另外，还有下面的方式表示不转义：

r'' -表示 ''  内部的字符串默认不转义

r'''...''' - 表示一对'''之间的多行内容均不转义 ；... 为交互代码输入时的显示效果，不需要手动码入。


![whats]({{ '/styles/images/post/16103101.png' | prepend: site.baseurl  }})


### #3.utf-8 注释

在python文件头添加utf-8注释，告诉解释器以UTF-8读取代码，避免中文乱码。

```

# -*- coding: utf-8 -*-

```

### #4.list & tuple

list基本操作

```

list1 = ['apple','opp',34,6.7]

list1[2] # 34

list1.append('append_end')

list1.insert(0,'add_first')

list1.pop(1)

len(list1)

```

tuple也是有序列表，但它与list最大的不同是tuple初始化后不能再进行修改。

```

tupleObj = (23,'jui')

tuple2=('only_one',)

```

注意:不可变指的是引用不可变，如果tuple中存放了list，该list里面的值可变，但指向的仍然是这个list

### #5.循环

Python提供一个range()函数，可以生成一个整数序列，例如

```

list(range(5)) 

# [0,1,2,3,4]  生产0-4的整数数列

```

### #6.交互式命令下自定义函数的引用

```

def my_abs(x):

	if x >0 :

		return x

	else:

		return -x

```

自定义了my_abs()的函数，保存为test.py文件，那么，可以在该文件的当前目录下启动Python解释器，用from test import my_abs来导入my_abs()函数，test是文件名,不含.py扩展名。

ps  文件名不能以数字开头，否则会报错...



### #7.pass的妙用

为了让代码跑起来，可以适当使用pass,比如想写一个躺着赚钱的方法，还没想好怎么做：

```

def lie_to_earn():

    pass

```



### #8.函数-默认参数

> (1) 默认参数必须指向不变对象，若指向可变对象，多次调用函数有可能造成结果重复。

```

def add_end(L=[]):    

    L.append('END')    

    return L

```

多次调用：

```

>>> add_end()
['END', 'END']
>>> add_end()
['END', 'END', 'END']
```
> (2) 必选参数在前，默认参数在后；



当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

> (3) 多个默认参数



有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)；

也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')。



### #9.函数参数 

关于必选参数、默认参数、可变参数、命名关键字参数和关键字参数。内容比较多，详见笔记《自定义函数参数》







----



----





### #10.切片

---- 对list/tuple切片 

（1）正向切片

```

#s[start:end:间隔数] end- 置空默认值为最后一个的索引；间隔数置空默认为1.

s=[1,2,3,4,5,6,7,8]

>>> s[2:6]

[3, 4, 5, 6]

>>> s[0:2]  

[1, 2]

>>> s[:2]    #第一个索引是零可以省略

[1, 2]

>>> s[::]

[1, 2, 3, 4, 5, 6, 7, 8]

>>> s[::2]

[1, 3, 5, 7]

# 切片的起始位置还可以用负数，表示倒着数。比如-1为倒数第一，既最后一个。正向切片开始位置必须小于结束位置，否则为空结果

>>> s[-4:-1:]  #默认不填的第三个间隔为 -1 

[5, 6, 7]

>>> s[-4:-7:]

[]

>>> s[-4:-1:2]

[5, 7]

>>> s[-4:0:2]

[]

>>> s[-4::2]  #默认不填的结束位置表示到最后一个

[5, 7]

```

（2）负向切片

```

>>> s[::-2]

[8, 6, 4, 2]  #倒序取



>>> s[-4:-2]

[5, 6]

>>> s[-4:0:] #负向切片需指定间隔为负，否则默认为1,取值为空

[]

>>> s[-4:0:-1]

[5, 4, 3, 2]



>>> s[-4:-8:-1]

[5, 4, 3, 2]

>>> s[-4::-1] 

[5, 4, 3, 2, 1]



>>> s[::-1]

[8, 7, 6, 5, 4, 3, 2, 1]

```

### #11. 偷懒的乘方

**　: 两个乘号就是乘方  eg:2**3,表示2的3次方

当然还有不是偷懒的乘方：调用pow    eg: pow(2,3)  还是2的三次方



### #12.map & filter

关于惰性序列。。

```

>>> def f(x): 

　　　  return x * x 

>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])

>>> list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81]

```

`map()`传入的第一个参数是f，即函数对象本身。由于结果r是一个`Iterato`r，`Iterator`是**惰性序列**，因此通过`list()`函数让它把整个序列都计算出来并返回一个list。同样的`filter()`返回的也是一个惰性序列`Iterator`。**惰性序列**的意思就是说，我很懒，不会提前计算出序列里的所有元素，我只会在迭代到当前位置时去计算元素。



### #12.迭代

判断是否可迭代:　`isinstance('sss',Iterable)`

使用`for...in`来迭代

迭代过程中需要下标：配合`enumerate`将list变成索引-元素再迭代

```

for i,val in enumerate(['a','aa','aaa']):

    print(i,val)

```

### #13.列表生成式

```

>>> [x * x for x in [2,4,5,3] if x % 2 == 0]

[4, 16]

```

```

>>> [o+ k for o in ['1-','2-','3-'] for k in ['Are','you','ok']]

 ['1-Are', '1-you', '1-ok', '2-Are', '2-you', '2-ok', '3-Are', '3-you', '3-ok']

```

```

>>> dict = {'o':'很','k':'好'}

>>> for k, v in dict.items():

...    print(k, '=', v)

k = 好

o = 很

```




